#!/usr/bin/perl
# Copyright and license are in the documentation below.

##############################################################################
### Configuration ############################################################
##############################################################################

## Modify and uncomment this to use user code instead of just system-wide
## modules, or to use development versions.
# use lib '/FULL/PATH/TO/PERL/MODULES';
# use lib "/afs/ir/users/t/s/tskirvin/private/work/remedy/libremedy-perl/lib";
# use lib "/afs/ir/users/t/s/tskirvin/private/work/remedy/Stanford-Remedy/lib";
# use lib "/afs/ir/users/t/s/tskirvin/private/work/remedy/libremedy-ticket-perl/lib";

## Number of days to go back for the 'unresolved' search. 
our $DAYS = 0;

## Print debugging information?  Set with '--debug', can be set many times
our $DEBUG = 0;

## Default group information.  Related to, but not set by, '--group'.
our $DEFAULT_GROUP = '';

## Default user information.  Related to, but not set by, '--user'.
our $DEFAULT_USER = $ENV{'REMOTE_USER'} || $ENV{'USER'} || "unknown";
    $DEFAULT_USER =~ s/\@.*$//;  # we only want the username

## Default request type, for convenience
our %DEFAULT = (
    'ticket' => '',
    'list'   => 'assign',
);

## Default ticket status for searching.
our $STATUS = 'open';

## In the 'time' functions, default number of minutes spent.
our $TIME = 0;

##############################################################################
### Declarations #############################################################
##############################################################################

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Remedy::Ticket;

$0 =~ s%.*/%%g;     # Lose the annoying path information
$|++;               # Flush output

use vars qw/$USER $GROUP/;

##############################################################################
### main () ##################################################################
##############################################################################

my $logger = Remedy::Log->get_logger;

my $parser = new Getopt::Long::Parser;
my $result = $parser->getoptions (
    'days=s'        => \$DAYS,
    'd|debug+'      => \$DEBUG,
    'group=s'       => \$GROUP,
    'status=s'      => \$STATUS,
    'time=s'        => \$TIME,
    'user=s'        => \$USER,
    'man'           => sub { pod2usage (-verbose => 2, -noperldoc => 1) },
    'h|help'        => sub { pod2usage (-verbose => 1) }) || error_usage ();

my $remedy = eval { Remedy::Ticket->connect ('debug' => $DEBUG) }
    or $logger->logdie ("couldn't connect to database: $@");
$logger->logdie ($@) if $@;

my ($query, @rest) = @ARGV;
$query ||= '(none)';
$query = lc $query;

if      ($query eq 'ticket') { 
    my ($number, $type) = @rest;
    $type ||= $DEFAULT{lc $query};
    $logger->info (sprintf ("text (%s, %s)", $number, $type || '(default)'));
    print scalar $remedy->text ($number, $type);
    exit 0;

} elsif ($query eq 'list') { 
    my ($type, $user, @extra) = @rest;
    $type ||= $DEFAULT{$query};
    $type = lc $type;

    my (%hash, @text);

    $user ||= $USER || $DEFAULT_USER;

    $hash{'user'}   = $USER   if defined $USER;
    $hash{'group'}  = $GROUP  if defined $GROUP;
    $hash{'status'} = $STATUS if defined $STATUS;

    if      ($type eq 'all') {
        
    } elsif ($type eq 'assign') {
        $hash{'assigned_user'} = $user;
        push @text, "assigned to '$user'";
        $user = '';

    } elsif ($type eq 'submit') {
        $hash{'submitted_user'} = $user;
        $USER = '';
        push @text, "submitted by '$user'";

    } elsif ($type eq 'unassigned') { 
        $hash{'unassigned'}++;
        push @text, "unassigned tickets";
        
        if ($USER) {
            $hash{'submitted_user'} = $USER;
            push @text, "submitted by '$USER'";
        }

    } elsif ($type eq '5day') {
        $hash{'status'} = 'open';
        $USER ||= $DEFAULT_USER;
        $DAYS ||= 5;
        push @text, "5 day report";

    } elsif ($type eq 'unresolved') { 
        $hash{'status'} = 'open';
        push @text, "open tickets";

    } elsif ($type eq 'resolved') { 
        $hash{'status'} = 'closed';
        push @text, "open tickets";

    } else { error_usage ("invalid list type: '$type'") }

    if ($DAYS) {
        $hash{'last_modify_before'} = time - $DAYS * 86400;
        push @text, "unmodified for $DAYS days";
    }

    if ($USER) { 
        my %person_search = ('SUNET ID' => $user);
        my @return = $remedy->read ('people', %person_search);
        $logger->logdie ("user '$user' does not belong to any groups")
            unless scalar @return;
        my @groups;
        foreach (@return) { push @groups, $_->groups }

        if (scalar @groups) {
            push @text, "in all member groups of '$user'";
            $hash{'groups'} = \@groups;
        }
    }

    $logger->info (sprintf ("finding %s", join (", ", @text)));
    foreach my $tkt ($remedy->read ('ticket', %hash)) { 
        print scalar $tkt->print ('short');
    }
    exit 0;


} elsif ($query eq 'assign') { 
    my ($number) = @rest;
    error_usage ('no ticket number') unless $number;

    my (%args, @text);
    if (defined $GROUP) { 
        $args{'group'} = $GROUP;
        push @text, "group $GROUP";
    }

    if (defined $USER) { 
        if ($USER) { 
            $args{'user'} = $USER;
            push @text, "user $USER";
        } else {
            $args{'user'} = undef;
            push @text, "no user";
        }
    } 
    error_usage ('no assignee information') unless scalar @text;
    my $text = join (', ', @text);;

    $logger->info ("assigning $number to $text");
    if (my $return = $remedy->assign ($number, %args)) {
        $logger->warn ("failed to assign $number: $return");
        exit 1;
    } else {
        $logger->warn ("assigned $number to $text");
        print scalar $remedy->text ($number, 'assign');
        exit 0;
    }

} elsif ($query eq 'unassign') {
    my ($number) = @rest;
    error_usage ('no ticket number') unless $number;

    if (my $return = $remedy->unassign ($number)) {
        $logger->warn ("failed to unassign $number: $return");
        exit 1;
    } else {
        $logger->warn ("unassigned $number");
        print scalar $remedy->text ($number, 'assign');
        exit 0;
    }
    

} elsif ($query eq 'status') {
    my ($number, $status) = @rest;
    error_usage ('no ticket number')  unless $number;
    error_usage ('no status offered') unless $status;
    
    $logger->info ("setting status of $number to '$status'");
    if (my $error = $remedy->set_status ($number, $status)) {
        print "failed to set status of $number to $status: $error";
        my $values = join (", ", $remedy->values ('Incident', 'Status'));
        print "valid status values: $values\n";
        exit 1;
    } else {
        print scalar $remedy->text ($number, 'primary');
        exit 0;
    }

} elsif ($query eq 'resolve') {
    my ($number, $text) = @rest;
    error_usage ('no text offered for resolution') unless $text;

    my %extra = ('timespent' => $TIME,
                 'user'      => $USER || $DEFAULT_USER);
    
    $logger->info ("resolving '$number'");
    if (my $error = $remedy->resolve ($number, $text, %extra)) {
        $logger->warn ("failed to resolve $number: $error");
        exit 1;
    } else {
        print "Resolved '$number'\n";
        print scalar $remedy->text ($number);
        exit 0;
    }

} elsif (lc $query eq 'worklog') { 
    my ($number, $text) = @rest;

    $logger->info ("Adding worklog information to ticket $number");
    my @tickets = $remedy->get ($number);
    $logger->logdie ("no matching tickets: '$number'") unless scalar @tickets;
    
    foreach my $tkt (@tickets) { 
        my $worklog = $tkt->worklog_create ();

        $worklog->details     ($text);
        $worklog->submitter   ($USER || $DEFAULT_USER);
        $worklog->description ("submitted through script '$0'");
        $worklog->type        ('General Information'); 
        $worklog->time_spent  ($TIME) if defined $TIME; 

        if (my $error = $worklog->save) {
            $logger->error ("error saving worklog entry: $error");
        } else {
            print "Worklog entry " . $worklog->id . " saved\n";        
            print scalar $worklog->print;
            exit 0;
        }
    }

} elsif (lc $query eq 'help') {
    pod2usage (-verbose => 2, -exit_status => 0, -noperldoc => 1);

} else { error_usage ("invalid query type: '$query'") }

exit 0;

##############################################################################
### Subroutines ##############################################################
##############################################################################

### error_usage (ERROR)
# Exit out with pod2usage
sub error_usage { 
    my ($error) = @_;
    my $logger = Remedy::Log->get_logger ();
    $logger->error ($error);
    pod2usage (-exit_status => 2, -verbose => 1);
}

##############################################################################
### Documentation ############################################################
##############################################################################

=head1 NAME

remedy-ticket - manage remedy tickets

=head1 SYNOPSIS

B<remedy-ticket> ticket I<NUMBER>

B<remedy-ticket> assign I<NUMBER> (--user I<USER>|--group I<GROUP>)

B<remedy-ticket> list I<TYPE> I<ARGS>

B<remedy-ticket> resolve I<NUMBER> I<TEXT>

B<remedy-ticket> status I<STATUS>

B<remedy-ticket> time_spent I<NUMBER> I<MINUTES>

B<remedy-ticket> unassign I<NUMBER>

B<remedy-ticket> worklog I<NUMBER> I<TEXT>

=head1 DESCRIPTION

remedy-ticket offers basic interfaces to the functions that the ITS Unix
Systems team needs to handle day-to-day ticket work without using a web
browser.  It is designed to be used through remctl.

=head1 OPTIONS

=over 4

=item B<-d>, B<--debug>

Print debugging information, both within this module and within the Remedy
module.  Can be offered multiple times to increase debugging accordingly.

=item B<--days> DAYS

For searches, how many days back should we look?

=item B<--group> GROUP 

For searches, what support group are we searching for?

=item B<-h>, B<--help>

Prints out the synopsis information and exits.

=item B<--man>

Prints out the full help documentation and exits.

=item B<--status> STATUS

For searches, what ticket status are we looking for?  

=item B<--time> TIME

For resolving tickets and creating worklogs, when should we say this input came
in?

=item B<--user> USER

For searches, what username are we searching for?

=back

=head1 EXAMPLES

=over 4

=item B<remedy-ticket> ticket I<NUMBER> (I<TYPE>)

Pulls ticket number I<NUMBER> and prints information about it.  By default,
this returns the primary ticket information (number, summary, status, etc), 
the requestor information, the assignee information, the user-provided
description, resolution information (if any), and worklog entries; but if
I<TYPE> is offered (and is from this list), then we will print different
information.

=over 2

=item assign

Just print the primary and assignment information.

=item audit

Print the audit lots for this entry.

=item debug

Print the raw data for this ticket.

=item primary

Just print the primary information.

=item summary

Print the primary information and a short summary of how much other data there
is regarding the ticket.

=item worklog

Print all worklog entries.

=back

Uses B<Remedy::Ticket::text ()>.

=item B<remedy-ticket> assign I<NUMBER> (--user I<USER>|--group I<GROUP>)

Assigns ticket I<NUMBER> to a group and/or user (at least one of which must be
offered).  

=item B<remedy-ticket> list I<TYPE> (I<USER> I<ARGS>)

Lists a short (3 lines or so) summary of each ticket matching the search time
from I<TYPE>.  I<USER> is a username (netid) that we will use in most searches;
if not offered, we will default to the value passed in from I<--user> (or the
user that invoked the script if neither is offered).

Valid types (along with the argument that they take, from I<ARGS>):

=over 2

=item 5day

The '5-day report' - shows open tickets that haven't been modified in 5 days
and are in groups associated with I<USER>.

=item all

Shows all tickets.  You'll probably want to restrict this.

=item assign

Show tickets assigned to I<USER>.

=item resolved

Only show closed tickets.

=item submit

Show tickets submitted by I<USER>.

=item unassigned

Only show unassigned tickets.  I<--user> was passed as a command line, then we
will also only show tickets submitted by that user.

=item unresolved

Only show open tickets.

=back

Additionally, we can add some more search requirements with some command-line
flags (which are sometimes overridden above).

=over 2

=item DAYS

Only show tickets that have been unmodified for this many days.

=item USER

Only show tickets that belong to a group that the given user belongs to.
Note that this is overridden 

=item GROUP

Only show tickets in the group I<GROUP>.

=back

=item B<remedy-ticket> resolve I<NUMBER> I<TEXT> [--time I<TIME>] [--user I<USER>]

Resolves the ticket I<NUMBER> with the text I<TEXT>.

=item B<remedy-ticket> status I<STATUS>

Sets the status of ticket I<NUMBER> to I<STATUS>.  On failure, this will list
the various status types; please note that business logic may make this
inaccurate.

=item B<remedy-ticket> unassign I<NUMBER>

Assigns ticket I<NUMBER> back to the help desk.

=item B<remedy-ticket> worklog I<NUMBER> I<TEXT>

Adds a worklog entry with the text I<TEXT> to the ticket I<NUMBER>.

=item B<remedy-ticket> time_spent I<NUMBER> I<MINUTES>

Adds I<MINUTES> minutes to the time spent on I<NUMBER>.

=back

=head1 REQUIREMENTS

B<Remedy::Ticket>

=head1 HOMEPAGE

TBD.

=head1 AUTHOR

Tim Skirvin <tskirvin@stanford.edu>

=head1 LICENSE

Copyright 2008-2009 Board of Trustees, Leland Stanford Jr. University

This program is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.

=cut
